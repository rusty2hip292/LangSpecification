
all "objects" are pointers to the object
	ie. MyObject mobj = new MyObject();
		mobj is a pointer to the MyObject internal structure representation

types can be nullable	#FOLD
	MyObject? may either be null or be a MyObject
	int? may either be null or an automatically dereferenced int pointer
	may nullify multiple times
	#ENDFOLD

objects automatically implement interfaces if they have the required methods, but may specify regardless	#FOLD
struct MyInterface {
	void *obj;		// object to call methods on
	/* interface metadata */
	Method *ptr1;	// interface methods
	Method *ptr2;	// ...
	...
}
MyInterface mi = new MyObject();	// automatically grabs the required methods and populates the interface object
#ENDFOLD

classes extend one class, implement unlimited interfaces
interfaces implement unlimited interfaces, "extending" the first specified

internal structure (draft)	#FOLD
// object structure
struct MyObject {
	struct Class *class;	// pointer to the class this object is an instance of
	int ref_ctr;			// number of references, for garbage collection
	int member_data1;		// member data
	char member_data2;		// ...
	...
}

// data metadata structure
// TODO make this an object type so that it is more flexible and can reference other types to form compound types
struct Meta {
	type_enum type;		// enum of all types, negative for primitive data
	int num_indirected;	// number of pointer levels (0 for MyObject, int, etc, 1 for int*, 2 for int**, etc)
	bool nullable;		// whether or not this is a nullable type (false for primatives, MyObject, etc, true for MyObject?, int?, etc)
	char *name;			// the name of this field or parameter
}

// class structure
struct Class {
	struct Class *super;			// pointer to super class, null only for root classes (Object in Java, idk if I'll do the same)
	struct ClassMeta *classmeta;	// metadata for the class
	struct Method *static;			// static methods, inherits from super class
	struct Method *vtable;			// array of instance methods
	struct Method *constructors;	// array of constructors
	struct Meta *member_fields;		// meta data for member fields
	struct Meta *static_fields;		// meta data for static fields
	int static_data1;				// static data
	char static_data2;				// ...
	...
}

// class metadata structure
struct ClassMeta {
	char *name;				// name of this class
	int id; int lower;		// each class has an id, lower is the lowest class id that extends this class, id is the highest
							// numbered by depth first search, lower is the recursive entry, id is exit
							// keep array of class structures, ordered by id (see class_id in object structure)
	int size_of_object;		// number of bytes of instances of this class, to use in copying
}

// method structure
struct Method {
	struct MethodMeta *meta;
	function_ptr *method;
}

// method metadata structure
struct MethodMeta {
	char *name;
	Meta *params;	// array of parameter metadata
}
#ENDFOLD

strongly typed, but also automatically typed	#FOLD
var x = /* some expression */;	// x has the type of the expression
var x = (Object) new MyObject();	// forces x to be of type Object
var x = (String) 5;				// casts may use (1) built in conversion methods, or (2) toType() methods
var x = (String) ((int) "5" + 6);	// implicitly does ("5".toint() + 6).toString()
var x = (String (int "5") + 6);	// for brevity and clarity, may place expression inside cast parenthesis
#ENDFOLD

powerful type system	#FOLD
class <int size>Stack<typename T> {	// internal subtyping with an integer, external generic type T
	<0>Stack<T>() { }			// requires T to be provided when calling
	void push<size + 1>(T t) {	// T is a class level type parameter
		// ...
	}
	T <size > 0>pop()<size - 1> {	// requires that size > 0 when this method is called, checked at compile time
		// ...
	}
}
class <typename Ts...>Stack {		// not multithreadable (how to specify?)		// internal list of types
	Stack() { }		// creates an empty stack, no type specification required
	
	// takes a stack of unspecified type list, returns void and pushes V into type list
	void <?Ts...>push(V v)<?Ts, V> {	// V is a function level type parameter
		// ...
	}
	
	// we are going to return the type of the last thing in the stack, which is then removed from the type list
	V <?Ts..., V>pop()<Ts> {
		// ...
	}
	
	void removeAll<V>() {	// need to specify V when we call this method
		// ... remove everything of type V
	}
}

var only_ints = new Stack<int>();	// can only push ints into this stack
var anything = new Stack();			// anything is a <>Stack
	anything.push("string");		// <String>Stack
	anything.push(5);				// <String, int>Stack
	var i = anything.pop();			// i is an integer, <String>Stack
	var str = anything.pop();		// str is a string, <>Stack
	var bad = anything.pop();		// compile time error because because there is known to be nothing in the stack
#ENDFOLD
